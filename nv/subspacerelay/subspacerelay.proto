syntax = "proto3";

package nv.subspacerelay;

import "google/protobuf/empty.proto";

option go_package = "github.com/nvx/subspace-relay;subspacerelaypb";

message Message {
  oneof message {
    // Payloads exchanged between a relay and a controller
    Payload payload = 1;

    // Load an emulation shortcut config into a supported card emulation relay
    // Shortcuts preempt a cAPDU from the reader with a given rAPDU response to reduce round trip delays
    // if multiple shortcuts match precedence of which shortcut is used is determined by the following
    // 1. chained_next from the previously matched cAPDU
    // 2. non-persistent shortcuts are checked before persistent shortcuts
    // 3. chained_next fields containing multiple EmulationShortcuts will check earlier array entries first
    // 4. non-chained shortcuts with explicit cAPDU headers are checked before wildcard header matches
    // 5. non-chained shortcuts with explicit data matches are checked before wildcard data matches
    // 6. non-chained older shortcuts preferred over newer - this may not always hold true due to network conditions
    // shortcuts are flushed when disconnect or reconnect messages are received by a relay unless persist_reconnect is true
    EmulationShortcut emulation_shortcut = 7;

    google.protobuf.Empty request_relay_info = 2;
    RelayInfo relay_info = 3;

    Log log = 4;

    // most connections are established automatically, or are driven ia external means (eg cardhopper entering a field)
    // but some remote-driven interactions (eg emulating a card) are still initiated from the local side (eg BLE) or
    // require setup (cardhopper emulation)
    Reconnect reconnect = 5;
    google.protobuf.Empty disconnect = 6;

    // Controllers can broadcast a request_relay_discovery message and all connected relays with discovery enabled will
    // respond with a relay_discovery response.
    // Supporting discovery is opt-in and relays may choose to only support encrypted discovery and optionally whitelist
    // specific controller public keys
    RequestRelayDiscovery request_relay_discovery = 8;
    // If a relay has discovery enabled it will emit a relay_discovery_plaintext or relay_discovery_encrypted broadcast
    // message on startup and in response to a received request_discovery message.
    // Supporting plaintext discovery removes the cryptographic guarantees that a malicious broker or anything that can
    // see the broker traffic can not view comms when cryptography using relay_ids is enabled.
    // A relay with discovery enabled  will support both plaintext and encrypted discovery unless a whitelisted public
    // key is specified at which point only encrypted discovery messages will be supported and the startup broadcast
    // will be encrypted with he provided public key
    RelayDiscovery relay_discovery_plaintext = 9;
    RelayDiscoveryEncrypted relay_discovery_encrypted = 10;
  }
}

enum PayloadType {
  PAYLOAD_TYPE_UNSPECIFIED = 0;
  // Relay device is attached to a HID reader or SAM and can exchange Artemis payloads
  PAYLOAD_TYPE_ARTEMIS = 1;
  // Relay device is attached to a Proxmark3 with the cardhopper standalone mode
  // This can be used to emulate a 14443a-4 card or act as a 14443a-4 reader
  // Payload is raw cardhopper frame
  PAYLOAD_TYPE_CARDHOPPER = 2;
  // Relay device is attached to a PCSC-like reader and can exchange APDUs to a smart card
  // This is most commonly used with CONNECTION_TYPE_PCSC, but may also be used with CONNECTION_TYPE_NFC and
  // CONNECTION_TYPE_BLE when acting as a reader
  PAYLOAD_TYPE_PCSC_READER = 3;
  // Relay device is attached to a PCSC-like reader that supports control commands
  // This is normally used with CONNECTION_TYPE_PCSC or CONNECTION_TYPE_PCSC_DIRECT
  PAYLOAD_TYPE_PCSC_READER_CONTROL = 5;
  // Relay device is emulating a smart card and can respond to APDUs from a reader
  PAYLOAD_TYPE_PCSC_CARD = 4;
}

enum ConnectionType {
  CONNECTION_TYPE_UNSPECIFIED = 0;
  CONNECTION_TYPE_PCSC = 1;
  CONNECTION_TYPE_PCSC_DIRECT = 6;
  CONNECTION_TYPE_UART = 2;
  CONNECTION_TYPE_OSDP = 3;
  CONNECTION_TYPE_NFC = 4;
  CONNECTION_TYPE_BLE = 5;
}

message Payload {
  bytes payload = 1;
  PayloadType payload_type = 2;
  uint32 sequence = 3;
  // control is used for PCSC control codes, only uint16 values are valid
  optional uint32 control = 4;
}

message EmulationShortcut {
  // cAPDU headers to match each value must be exactly 4 bytes (CLA INS P1 P2)
  // if omitted will wildcard match any header
  repeated bytes capdu_header = 1;
  // data to match
  // if omitted will wildcard any data value
  repeated bytes capdu_data = 2;
  // rAPDU to respond to the matching shortcut cAPDU
  bytes rapdu = 3;
  // if false after the first match the shortcut is forgotten
  // if true it will remain until disconnect or reconnect is received
  // persistent should only be specified for non rpc replies
  // if the persistent flag is present on chained_next fields that set of shortcuts will persist until it no longer matches
  bool persistent = 4;
  // if true shortcut will persist disconnect/reconnect cycles
  bool persist_reconnect = 7;
  // if true the matching cAPDU received from the reader will be will be sent as a Payload back to the client
  bool send_capdu = 5;
  // expect the following as the immediate next shortcut to occur to enable response chaining
  // if the shortcut does not match the next cAPDU it is discarded
  repeated EmulationShortcut chained_next = 6;
}

message Reconnect {
  reserved 1;
  // uid may not be supported by all card emulators
  bytes uid = 2;
  // ats may not be supported by all card emulators
  bytes ats = 3;
  // some card emulator relays may need an explicit list of AIDs to register (eg Mobile HCE) or they will not be visible
  // if the relay does not have this requirement it will be ignored
  repeated bytes aid_list = 4;
  // initial list of EmulationShortcuts to load
  repeated EmulationShortcut shortcuts = 5;
  // force flush all shortcuts, even those with persist_reconnect set to true
  bool force_flush_shortcuts = 6;
}

message RelayInfo {
  repeated PayloadType supported_payload_types = 1;
  ConnectionType connection_type = 5;
  // atr is only present when PAYLOAD_TYPE_PCSC_READER is in supported_payload_types and supported by the reader
  bytes atr = 2;
  // device_name is only present when available, eg for PCSC readers or when connected to a BLE peripheral
  string device_name = 3;
  // device_address is only present when available, eg when connected to a BLE peripheral
  bytes device_address = 4;
  // rssi is only present when available, eg when connected to a BLE peripheral
  sint32 rssi = 6;
  // true iff EmulationShortcut messages are supported
  bool supports_shortcut = 7;
  // true iff card emulation requires an explicit list of AIDs in the Reconnect message
  bool requires_aid_list = 8;
  // user agent is an optional name/version of the relay application
  string user_agent = 9;
  // Optional parameters for NFC cards. May not always be populated, eg PCSC readers may require querying via pseudo APDUs
  bytes uid = 10;
  bytes atqa = 11;
  bytes sak = 12;
  bytes ats = 13;
}

message RequestRelayDiscovery {
  // Optional X5519 public key of the controller that the relay should use to encrypt the discovery response with
  bytes controller_public_key = 1;
  // Optional payload type the controller is looking for. If specified  relays should only respond if it supports the
  // provided payload type.
  PayloadType payload_type = 2;
}

message RelayDiscovery {
  string relay_id = 1;
  RelayInfo relay_info = 2;
}

message RelayDiscoveryEncrypted {
  // controller public key must match the public key specified in the RequestRelayDiscovery message
  bytes controller_public_key = 1;
  // the relay public key should be randomly generated each time a discovery request is received
  bytes relay_public_key = 2;
  // encrypted_relay_discovery contains an encrypted RelayDiscovery message encrypted with AES128-GCM using keys
  // negotiated with ECDH X5519
  bytes encrypted_relay_discovery = 3;
}

message Log {
  string message = 1;
}
