// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: nv/subspacerelay/subspacerelay.proto

package subspacerelaypb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PayloadType int32

const (
	PayloadType_PAYLOAD_TYPE_UNSPECIFIED PayloadType = 0
	// Relay device is attached to a HID reader or SAM and can exchange Artemis payloads
	PayloadType_PAYLOAD_TYPE_ARTEMIS PayloadType = 1
	// Relay device is attached to a Proxmark3 with the cardhopper standalone mode
	// This can be used to emulate a 14443a-4 card or act as a 14443a-4 reader
	// Payload is raw cardhopper frame
	PayloadType_PAYLOAD_TYPE_CARDHOPPER PayloadType = 2
	// Relay device is attached to a PCSC-like reader and can exchange APDUs to a smart card
	// This is most commonly used with CONNECTION_TYPE_PCSC, but may also be used with CONNECTION_TYPE_NFC and
	// CONNECTION_TYPE_BLE when acting as a reader
	PayloadType_PAYLOAD_TYPE_PCSC_READER PayloadType = 3
	// Relay device is attached to a PCSC-like reader that supports control commands
	// This is normally used with CONNECTION_TYPE_PCSC or CONNECTION_TYPE_PCSC_DIRECT
	PayloadType_PAYLOAD_TYPE_PCSC_READER_CONTROL PayloadType = 5
	// Relay device is emulating a smart card and can respond to APDUs from a reader
	PayloadType_PAYLOAD_TYPE_PCSC_CARD PayloadType = 4
)

// Enum value maps for PayloadType.
var (
	PayloadType_name = map[int32]string{
		0: "PAYLOAD_TYPE_UNSPECIFIED",
		1: "PAYLOAD_TYPE_ARTEMIS",
		2: "PAYLOAD_TYPE_CARDHOPPER",
		3: "PAYLOAD_TYPE_PCSC_READER",
		5: "PAYLOAD_TYPE_PCSC_READER_CONTROL",
		4: "PAYLOAD_TYPE_PCSC_CARD",
	}
	PayloadType_value = map[string]int32{
		"PAYLOAD_TYPE_UNSPECIFIED":         0,
		"PAYLOAD_TYPE_ARTEMIS":             1,
		"PAYLOAD_TYPE_CARDHOPPER":          2,
		"PAYLOAD_TYPE_PCSC_READER":         3,
		"PAYLOAD_TYPE_PCSC_READER_CONTROL": 5,
		"PAYLOAD_TYPE_PCSC_CARD":           4,
	}
)

func (x PayloadType) Enum() *PayloadType {
	p := new(PayloadType)
	*p = x
	return p
}

func (x PayloadType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PayloadType) Descriptor() protoreflect.EnumDescriptor {
	return file_nv_subspacerelay_subspacerelay_proto_enumTypes[0].Descriptor()
}

func (PayloadType) Type() protoreflect.EnumType {
	return &file_nv_subspacerelay_subspacerelay_proto_enumTypes[0]
}

func (x PayloadType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PayloadType.Descriptor instead.
func (PayloadType) EnumDescriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{0}
}

type ConnectionType int32

const (
	ConnectionType_CONNECTION_TYPE_UNSPECIFIED ConnectionType = 0
	ConnectionType_CONNECTION_TYPE_PCSC        ConnectionType = 1
	ConnectionType_CONNECTION_TYPE_PCSC_DIRECT ConnectionType = 6
	ConnectionType_CONNECTION_TYPE_UART        ConnectionType = 2
	ConnectionType_CONNECTION_TYPE_OSDP        ConnectionType = 3
	ConnectionType_CONNECTION_TYPE_NFC         ConnectionType = 4
	ConnectionType_CONNECTION_TYPE_BLE         ConnectionType = 5
)

// Enum value maps for ConnectionType.
var (
	ConnectionType_name = map[int32]string{
		0: "CONNECTION_TYPE_UNSPECIFIED",
		1: "CONNECTION_TYPE_PCSC",
		6: "CONNECTION_TYPE_PCSC_DIRECT",
		2: "CONNECTION_TYPE_UART",
		3: "CONNECTION_TYPE_OSDP",
		4: "CONNECTION_TYPE_NFC",
		5: "CONNECTION_TYPE_BLE",
	}
	ConnectionType_value = map[string]int32{
		"CONNECTION_TYPE_UNSPECIFIED": 0,
		"CONNECTION_TYPE_PCSC":        1,
		"CONNECTION_TYPE_PCSC_DIRECT": 6,
		"CONNECTION_TYPE_UART":        2,
		"CONNECTION_TYPE_OSDP":        3,
		"CONNECTION_TYPE_NFC":         4,
		"CONNECTION_TYPE_BLE":         5,
	}
)

func (x ConnectionType) Enum() *ConnectionType {
	p := new(ConnectionType)
	*p = x
	return p
}

func (x ConnectionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConnectionType) Descriptor() protoreflect.EnumDescriptor {
	return file_nv_subspacerelay_subspacerelay_proto_enumTypes[1].Descriptor()
}

func (ConnectionType) Type() protoreflect.EnumType {
	return &file_nv_subspacerelay_subspacerelay_proto_enumTypes[1]
}

func (x ConnectionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ConnectionType.Descriptor instead.
func (ConnectionType) EnumDescriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{1}
}

type Message struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Message:
	//
	//	*Message_Payload
	//	*Message_EmulationShortcut
	//	*Message_RequestRelayInfo
	//	*Message_RelayInfo
	//	*Message_Log
	//	*Message_Reconnect
	//	*Message_Disconnect
	//	*Message_RequestRelayDiscovery
	//	*Message_RelayDiscoveryPlaintext
	//	*Message_RelayDiscoveryEncrypted
	Message       isMessage_Message `protobuf_oneof:"message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Message) Reset() {
	*x = Message{}
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Message) ProtoMessage() {}

func (x *Message) ProtoReflect() protoreflect.Message {
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Message.ProtoReflect.Descriptor instead.
func (*Message) Descriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{0}
}

func (x *Message) GetMessage() isMessage_Message {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *Message) GetPayload() *Payload {
	if x != nil {
		if x, ok := x.Message.(*Message_Payload); ok {
			return x.Payload
		}
	}
	return nil
}

func (x *Message) GetEmulationShortcut() *EmulationShortcut {
	if x != nil {
		if x, ok := x.Message.(*Message_EmulationShortcut); ok {
			return x.EmulationShortcut
		}
	}
	return nil
}

func (x *Message) GetRequestRelayInfo() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Message.(*Message_RequestRelayInfo); ok {
			return x.RequestRelayInfo
		}
	}
	return nil
}

func (x *Message) GetRelayInfo() *RelayInfo {
	if x != nil {
		if x, ok := x.Message.(*Message_RelayInfo); ok {
			return x.RelayInfo
		}
	}
	return nil
}

func (x *Message) GetLog() *Log {
	if x != nil {
		if x, ok := x.Message.(*Message_Log); ok {
			return x.Log
		}
	}
	return nil
}

func (x *Message) GetReconnect() *Reconnect {
	if x != nil {
		if x, ok := x.Message.(*Message_Reconnect); ok {
			return x.Reconnect
		}
	}
	return nil
}

func (x *Message) GetDisconnect() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Message.(*Message_Disconnect); ok {
			return x.Disconnect
		}
	}
	return nil
}

func (x *Message) GetRequestRelayDiscovery() *RequestRelayDiscovery {
	if x != nil {
		if x, ok := x.Message.(*Message_RequestRelayDiscovery); ok {
			return x.RequestRelayDiscovery
		}
	}
	return nil
}

func (x *Message) GetRelayDiscoveryPlaintext() *RelayDiscovery {
	if x != nil {
		if x, ok := x.Message.(*Message_RelayDiscoveryPlaintext); ok {
			return x.RelayDiscoveryPlaintext
		}
	}
	return nil
}

func (x *Message) GetRelayDiscoveryEncrypted() *RelayDiscoveryEncrypted {
	if x != nil {
		if x, ok := x.Message.(*Message_RelayDiscoveryEncrypted); ok {
			return x.RelayDiscoveryEncrypted
		}
	}
	return nil
}

type isMessage_Message interface {
	isMessage_Message()
}

type Message_Payload struct {
	// Payloads exchanged between a relay and a controller
	Payload *Payload `protobuf:"bytes,1,opt,name=payload,proto3,oneof"`
}

type Message_EmulationShortcut struct {
	// Load an emulation shortcut config into a supported card emulation relay
	// Shortcuts preempt a cAPDU from the reader with a given rAPDU response to reduce round trip delays
	// if multiple shortcuts match precedence of which shortcut is used is determined by the following
	// 1. chained_next from the previously matched cAPDU
	// 2. non-persistent shortcuts are checked before persistent shortcuts
	// 3. chained_next fields containing multiple EmulationShortcuts will check earlier array entries first
	// 4. non-chained shortcuts with explicit cAPDU headers are checked before wildcard header matches
	// 5. non-chained shortcuts with explicit data matches are checked before wildcard data matches
	// 6. non-chained older shortcuts preferred over newer - this may not always hold true due to network conditions
	// shortcuts are flushed when disconnect or reconnect messages are received by a relay unless persist_reconnect is true
	EmulationShortcut *EmulationShortcut `protobuf:"bytes,7,opt,name=emulation_shortcut,json=emulationShortcut,proto3,oneof"`
}

type Message_RequestRelayInfo struct {
	RequestRelayInfo *emptypb.Empty `protobuf:"bytes,2,opt,name=request_relay_info,json=requestRelayInfo,proto3,oneof"`
}

type Message_RelayInfo struct {
	RelayInfo *RelayInfo `protobuf:"bytes,3,opt,name=relay_info,json=relayInfo,proto3,oneof"`
}

type Message_Log struct {
	Log *Log `protobuf:"bytes,4,opt,name=log,proto3,oneof"`
}

type Message_Reconnect struct {
	// most connections are established automatically, or are driven ia external means (eg cardhopper entering a field)
	// but some remote-driven interactions (eg emulating a card) are still initiated from the local side (eg BLE) or
	// require setup (cardhopper emulation)
	Reconnect *Reconnect `protobuf:"bytes,5,opt,name=reconnect,proto3,oneof"`
}

type Message_Disconnect struct {
	Disconnect *emptypb.Empty `protobuf:"bytes,6,opt,name=disconnect,proto3,oneof"`
}

type Message_RequestRelayDiscovery struct {
	// Controllers can broadcast a request_relay_discovery message and all connected relays with discovery enabled will
	// respond with a relay_discovery response.
	// Supporting discovery is opt-in and relays may choose to only support encrypted discovery and optionally whitelist
	// specific controller public keys
	RequestRelayDiscovery *RequestRelayDiscovery `protobuf:"bytes,8,opt,name=request_relay_discovery,json=requestRelayDiscovery,proto3,oneof"`
}

type Message_RelayDiscoveryPlaintext struct {
	// If a relay has discovery enabled it will emit a relay_discovery_plaintext or relay_discovery_encrypted broadcast
	// message on startup and in response to a received request_discovery message.
	// Supporting plaintext discovery removes the cryptographic guarantees that a malicious broker or anything that can
	// see the broker traffic can not view comms when cryptography using relay_ids is enabled.
	// A relay with discovery enabled  will support both plaintext and encrypted discovery unless a whitelisted public
	// key is specified at which point only encrypted discovery messages will be supported and the startup broadcast
	// will be encrypted with he provided public key
	RelayDiscoveryPlaintext *RelayDiscovery `protobuf:"bytes,9,opt,name=relay_discovery_plaintext,json=relayDiscoveryPlaintext,proto3,oneof"`
}

type Message_RelayDiscoveryEncrypted struct {
	RelayDiscoveryEncrypted *RelayDiscoveryEncrypted `protobuf:"bytes,10,opt,name=relay_discovery_encrypted,json=relayDiscoveryEncrypted,proto3,oneof"`
}

func (*Message_Payload) isMessage_Message() {}

func (*Message_EmulationShortcut) isMessage_Message() {}

func (*Message_RequestRelayInfo) isMessage_Message() {}

func (*Message_RelayInfo) isMessage_Message() {}

func (*Message_Log) isMessage_Message() {}

func (*Message_Reconnect) isMessage_Message() {}

func (*Message_Disconnect) isMessage_Message() {}

func (*Message_RequestRelayDiscovery) isMessage_Message() {}

func (*Message_RelayDiscoveryPlaintext) isMessage_Message() {}

func (*Message_RelayDiscoveryEncrypted) isMessage_Message() {}

type Payload struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Payload     []byte                 `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	PayloadType PayloadType            `protobuf:"varint,2,opt,name=payload_type,json=payloadType,proto3,enum=nv.subspacerelay.PayloadType" json:"payload_type,omitempty"`
	Sequence    uint32                 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// control is used for PCSC control codes, only uint16 values are valid
	Control       *uint32 `protobuf:"varint,4,opt,name=control,proto3,oneof" json:"control,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Payload) Reset() {
	*x = Payload{}
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Payload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Payload) ProtoMessage() {}

func (x *Payload) ProtoReflect() protoreflect.Message {
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Payload.ProtoReflect.Descriptor instead.
func (*Payload) Descriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{1}
}

func (x *Payload) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Payload) GetPayloadType() PayloadType {
	if x != nil {
		return x.PayloadType
	}
	return PayloadType_PAYLOAD_TYPE_UNSPECIFIED
}

func (x *Payload) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *Payload) GetControl() uint32 {
	if x != nil && x.Control != nil {
		return *x.Control
	}
	return 0
}

type EmulationShortcut struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// cAPDU headers to match each value must be exactly 4 bytes (CLA INS P1 P2)
	// if omitted will wildcard match any header
	CapduHeader [][]byte `protobuf:"bytes,1,rep,name=capdu_header,json=capduHeader,proto3" json:"capdu_header,omitempty"`
	// data to match
	// if omitted will wildcard any data value
	CapduData [][]byte `protobuf:"bytes,2,rep,name=capdu_data,json=capduData,proto3" json:"capdu_data,omitempty"`
	// rAPDU to respond to the matching shortcut cAPDU
	Rapdu []byte `protobuf:"bytes,3,opt,name=rapdu,proto3" json:"rapdu,omitempty"`
	// if false after the first match the shortcut is forgotten
	// if true it will remain until disconnect or reconnect is received
	// persistent should only be specified for non rpc replies
	// if the persistent flag is present on chained_next fields that set of shortcuts will persist until it no longer matches
	Persistent bool `protobuf:"varint,4,opt,name=persistent,proto3" json:"persistent,omitempty"`
	// if true shortcut will persist disconnect/reconnect cycles
	PersistReconnect bool `protobuf:"varint,7,opt,name=persist_reconnect,json=persistReconnect,proto3" json:"persist_reconnect,omitempty"`
	// if true the matching cAPDU received from the reader will be will be sent as a Payload back to the client
	SendCapdu bool `protobuf:"varint,5,opt,name=send_capdu,json=sendCapdu,proto3" json:"send_capdu,omitempty"`
	// expect the following as the immediate next shortcut to occur to enable response chaining
	// if the shortcut does not match the next cAPDU it is discarded
	ChainedNext   []*EmulationShortcut `protobuf:"bytes,6,rep,name=chained_next,json=chainedNext,proto3" json:"chained_next,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EmulationShortcut) Reset() {
	*x = EmulationShortcut{}
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmulationShortcut) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmulationShortcut) ProtoMessage() {}

func (x *EmulationShortcut) ProtoReflect() protoreflect.Message {
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmulationShortcut.ProtoReflect.Descriptor instead.
func (*EmulationShortcut) Descriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{2}
}

func (x *EmulationShortcut) GetCapduHeader() [][]byte {
	if x != nil {
		return x.CapduHeader
	}
	return nil
}

func (x *EmulationShortcut) GetCapduData() [][]byte {
	if x != nil {
		return x.CapduData
	}
	return nil
}

func (x *EmulationShortcut) GetRapdu() []byte {
	if x != nil {
		return x.Rapdu
	}
	return nil
}

func (x *EmulationShortcut) GetPersistent() bool {
	if x != nil {
		return x.Persistent
	}
	return false
}

func (x *EmulationShortcut) GetPersistReconnect() bool {
	if x != nil {
		return x.PersistReconnect
	}
	return false
}

func (x *EmulationShortcut) GetSendCapdu() bool {
	if x != nil {
		return x.SendCapdu
	}
	return false
}

func (x *EmulationShortcut) GetChainedNext() []*EmulationShortcut {
	if x != nil {
		return x.ChainedNext
	}
	return nil
}

type Reconnect struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// uid may not be supported by all card emulators
	Uid []byte `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// ats may not be supported by all card emulators
	Ats []byte `protobuf:"bytes,3,opt,name=ats,proto3" json:"ats,omitempty"`
	// some card emulator relays may need an explicit list of AIDs to register (eg Mobile HCE) or they will not be visible
	// if the relay does not have this requirement it will be ignored
	AidList [][]byte `protobuf:"bytes,4,rep,name=aid_list,json=aidList,proto3" json:"aid_list,omitempty"`
	// initial list of EmulationShortcuts to load
	Shortcuts []*EmulationShortcut `protobuf:"bytes,5,rep,name=shortcuts,proto3" json:"shortcuts,omitempty"`
	// force flush all shortcuts, even those with persist_reconnect set to true
	ForceFlushShortcuts bool `protobuf:"varint,6,opt,name=force_flush_shortcuts,json=forceFlushShortcuts,proto3" json:"force_flush_shortcuts,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Reconnect) Reset() {
	*x = Reconnect{}
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Reconnect) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Reconnect) ProtoMessage() {}

func (x *Reconnect) ProtoReflect() protoreflect.Message {
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Reconnect.ProtoReflect.Descriptor instead.
func (*Reconnect) Descriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{3}
}

func (x *Reconnect) GetUid() []byte {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Reconnect) GetAts() []byte {
	if x != nil {
		return x.Ats
	}
	return nil
}

func (x *Reconnect) GetAidList() [][]byte {
	if x != nil {
		return x.AidList
	}
	return nil
}

func (x *Reconnect) GetShortcuts() []*EmulationShortcut {
	if x != nil {
		return x.Shortcuts
	}
	return nil
}

func (x *Reconnect) GetForceFlushShortcuts() bool {
	if x != nil {
		return x.ForceFlushShortcuts
	}
	return false
}

type RelayInfo struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	SupportedPayloadTypes []PayloadType          `protobuf:"varint,1,rep,packed,name=supported_payload_types,json=supportedPayloadTypes,proto3,enum=nv.subspacerelay.PayloadType" json:"supported_payload_types,omitempty"`
	ConnectionType        ConnectionType         `protobuf:"varint,5,opt,name=connection_type,json=connectionType,proto3,enum=nv.subspacerelay.ConnectionType" json:"connection_type,omitempty"`
	// atr is only present when PAYLOAD_TYPE_PCSC_READER is in supported_payload_types and supported by the reader
	Atr []byte `protobuf:"bytes,2,opt,name=atr,proto3" json:"atr,omitempty"`
	// device_name is only present when available, eg for PCSC readers or when connected to a BLE peripheral
	DeviceName string `protobuf:"bytes,3,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	// device_address is only present when available, eg when connected to a BLE peripheral
	DeviceAddress []byte `protobuf:"bytes,4,opt,name=device_address,json=deviceAddress,proto3" json:"device_address,omitempty"`
	// rssi is only present when available, eg when connected to a BLE peripheral
	Rssi int32 `protobuf:"zigzag32,6,opt,name=rssi,proto3" json:"rssi,omitempty"`
	// true iff EmulationShortcut messages are supported
	SupportsShortcut bool `protobuf:"varint,7,opt,name=supports_shortcut,json=supportsShortcut,proto3" json:"supports_shortcut,omitempty"`
	// true iff card emulation requires an explicit list of AIDs in the Reconnect message
	RequiresAidList bool `protobuf:"varint,8,opt,name=requires_aid_list,json=requiresAidList,proto3" json:"requires_aid_list,omitempty"`
	// user agent is an optional name/version of the relay application
	UserAgent string `protobuf:"bytes,9,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
	// Optional parameters for NFC cards. May not always be populated, eg PCSC readers may require querying via pseudo APDUs
	Uid           []byte `protobuf:"bytes,10,opt,name=uid,proto3" json:"uid,omitempty"`
	Atqa          []byte `protobuf:"bytes,11,opt,name=atqa,proto3" json:"atqa,omitempty"`
	Sak           []byte `protobuf:"bytes,12,opt,name=sak,proto3" json:"sak,omitempty"`
	Ats           []byte `protobuf:"bytes,13,opt,name=ats,proto3" json:"ats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelayInfo) Reset() {
	*x = RelayInfo{}
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelayInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayInfo) ProtoMessage() {}

func (x *RelayInfo) ProtoReflect() protoreflect.Message {
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayInfo.ProtoReflect.Descriptor instead.
func (*RelayInfo) Descriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{4}
}

func (x *RelayInfo) GetSupportedPayloadTypes() []PayloadType {
	if x != nil {
		return x.SupportedPayloadTypes
	}
	return nil
}

func (x *RelayInfo) GetConnectionType() ConnectionType {
	if x != nil {
		return x.ConnectionType
	}
	return ConnectionType_CONNECTION_TYPE_UNSPECIFIED
}

func (x *RelayInfo) GetAtr() []byte {
	if x != nil {
		return x.Atr
	}
	return nil
}

func (x *RelayInfo) GetDeviceName() string {
	if x != nil {
		return x.DeviceName
	}
	return ""
}

func (x *RelayInfo) GetDeviceAddress() []byte {
	if x != nil {
		return x.DeviceAddress
	}
	return nil
}

func (x *RelayInfo) GetRssi() int32 {
	if x != nil {
		return x.Rssi
	}
	return 0
}

func (x *RelayInfo) GetSupportsShortcut() bool {
	if x != nil {
		return x.SupportsShortcut
	}
	return false
}

func (x *RelayInfo) GetRequiresAidList() bool {
	if x != nil {
		return x.RequiresAidList
	}
	return false
}

func (x *RelayInfo) GetUserAgent() string {
	if x != nil {
		return x.UserAgent
	}
	return ""
}

func (x *RelayInfo) GetUid() []byte {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *RelayInfo) GetAtqa() []byte {
	if x != nil {
		return x.Atqa
	}
	return nil
}

func (x *RelayInfo) GetSak() []byte {
	if x != nil {
		return x.Sak
	}
	return nil
}

func (x *RelayInfo) GetAts() []byte {
	if x != nil {
		return x.Ats
	}
	return nil
}

type RequestRelayDiscovery struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional X5519 public key of the controller that the relay should use to encrypt the discovery response with
	ControllerPublicKey []byte `protobuf:"bytes,1,opt,name=controller_public_key,json=controllerPublicKey,proto3" json:"controller_public_key,omitempty"`
	// Optional payload type the controller is looking for. If specified  relays should only respond if it supports the
	// provided payload type.
	PayloadTypes  []PayloadType `protobuf:"varint,2,rep,packed,name=payload_types,json=payloadTypes,proto3,enum=nv.subspacerelay.PayloadType" json:"payload_types,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequestRelayDiscovery) Reset() {
	*x = RequestRelayDiscovery{}
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestRelayDiscovery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestRelayDiscovery) ProtoMessage() {}

func (x *RequestRelayDiscovery) ProtoReflect() protoreflect.Message {
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestRelayDiscovery.ProtoReflect.Descriptor instead.
func (*RequestRelayDiscovery) Descriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{5}
}

func (x *RequestRelayDiscovery) GetControllerPublicKey() []byte {
	if x != nil {
		return x.ControllerPublicKey
	}
	return nil
}

func (x *RequestRelayDiscovery) GetPayloadTypes() []PayloadType {
	if x != nil {
		return x.PayloadTypes
	}
	return nil
}

type RelayDiscovery struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RelayId       string                 `protobuf:"bytes,1,opt,name=relay_id,json=relayId,proto3" json:"relay_id,omitempty"`
	RelayInfo     *RelayInfo             `protobuf:"bytes,2,opt,name=relay_info,json=relayInfo,proto3" json:"relay_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelayDiscovery) Reset() {
	*x = RelayDiscovery{}
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelayDiscovery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayDiscovery) ProtoMessage() {}

func (x *RelayDiscovery) ProtoReflect() protoreflect.Message {
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayDiscovery.ProtoReflect.Descriptor instead.
func (*RelayDiscovery) Descriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{6}
}

func (x *RelayDiscovery) GetRelayId() string {
	if x != nil {
		return x.RelayId
	}
	return ""
}

func (x *RelayDiscovery) GetRelayInfo() *RelayInfo {
	if x != nil {
		return x.RelayInfo
	}
	return nil
}

type RelayDiscoveryEncrypted struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// controller public key must match the public key specified in the RequestRelayDiscovery message
	ControllerPublicKey []byte `protobuf:"bytes,1,opt,name=controller_public_key,json=controllerPublicKey,proto3" json:"controller_public_key,omitempty"`
	// the relay public key should be randomly generated each time a discovery request is received
	RelayPublicKey []byte `protobuf:"bytes,2,opt,name=relay_public_key,json=relayPublicKey,proto3" json:"relay_public_key,omitempty"`
	// encrypted_relay_discovery contains an encrypted RelayDiscovery message encrypted with AES128-GCM using keys
	// negotiated with ECDH X5519
	EncryptedRelayDiscovery []byte `protobuf:"bytes,3,opt,name=encrypted_relay_discovery,json=encryptedRelayDiscovery,proto3" json:"encrypted_relay_discovery,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *RelayDiscoveryEncrypted) Reset() {
	*x = RelayDiscoveryEncrypted{}
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelayDiscoveryEncrypted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayDiscoveryEncrypted) ProtoMessage() {}

func (x *RelayDiscoveryEncrypted) ProtoReflect() protoreflect.Message {
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayDiscoveryEncrypted.ProtoReflect.Descriptor instead.
func (*RelayDiscoveryEncrypted) Descriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{7}
}

func (x *RelayDiscoveryEncrypted) GetControllerPublicKey() []byte {
	if x != nil {
		return x.ControllerPublicKey
	}
	return nil
}

func (x *RelayDiscoveryEncrypted) GetRelayPublicKey() []byte {
	if x != nil {
		return x.RelayPublicKey
	}
	return nil
}

func (x *RelayDiscoveryEncrypted) GetEncryptedRelayDiscovery() []byte {
	if x != nil {
		return x.EncryptedRelayDiscovery
	}
	return nil
}

type Log struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Message       string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Log) Reset() {
	*x = Log{}
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Log) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Log) ProtoMessage() {}

func (x *Log) ProtoReflect() protoreflect.Message {
	mi := &file_nv_subspacerelay_subspacerelay_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Log.ProtoReflect.Descriptor instead.
func (*Log) Descriptor() ([]byte, []int) {
	return file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP(), []int{8}
}

func (x *Log) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

var File_nv_subspacerelay_subspacerelay_proto protoreflect.FileDescriptor

const file_nv_subspacerelay_subspacerelay_proto_rawDesc = "" +
	"\n" +
	"$nv/subspacerelay/subspacerelay.proto\x12\x10nv.subspacerelay\x1a\x1bgoogle/protobuf/empty.proto\"\xf5\x05\n" +
	"\aMessage\x125\n" +
	"\apayload\x18\x01 \x01(\v2\x19.nv.subspacerelay.PayloadH\x00R\apayload\x12T\n" +
	"\x12emulation_shortcut\x18\a \x01(\v2#.nv.subspacerelay.EmulationShortcutH\x00R\x11emulationShortcut\x12F\n" +
	"\x12request_relay_info\x18\x02 \x01(\v2\x16.google.protobuf.EmptyH\x00R\x10requestRelayInfo\x12<\n" +
	"\n" +
	"relay_info\x18\x03 \x01(\v2\x1b.nv.subspacerelay.RelayInfoH\x00R\trelayInfo\x12)\n" +
	"\x03log\x18\x04 \x01(\v2\x15.nv.subspacerelay.LogH\x00R\x03log\x12;\n" +
	"\treconnect\x18\x05 \x01(\v2\x1b.nv.subspacerelay.ReconnectH\x00R\treconnect\x128\n" +
	"\n" +
	"disconnect\x18\x06 \x01(\v2\x16.google.protobuf.EmptyH\x00R\n" +
	"disconnect\x12a\n" +
	"\x17request_relay_discovery\x18\b \x01(\v2'.nv.subspacerelay.RequestRelayDiscoveryH\x00R\x15requestRelayDiscovery\x12^\n" +
	"\x19relay_discovery_plaintext\x18\t \x01(\v2 .nv.subspacerelay.RelayDiscoveryH\x00R\x17relayDiscoveryPlaintext\x12g\n" +
	"\x19relay_discovery_encrypted\x18\n" +
	" \x01(\v2).nv.subspacerelay.RelayDiscoveryEncryptedH\x00R\x17relayDiscoveryEncryptedB\t\n" +
	"\amessage\"\xac\x01\n" +
	"\aPayload\x12\x18\n" +
	"\apayload\x18\x01 \x01(\fR\apayload\x12@\n" +
	"\fpayload_type\x18\x02 \x01(\x0e2\x1d.nv.subspacerelay.PayloadTypeR\vpayloadType\x12\x1a\n" +
	"\bsequence\x18\x03 \x01(\rR\bsequence\x12\x1d\n" +
	"\acontrol\x18\x04 \x01(\rH\x00R\acontrol\x88\x01\x01B\n" +
	"\n" +
	"\b_control\"\x9f\x02\n" +
	"\x11EmulationShortcut\x12!\n" +
	"\fcapdu_header\x18\x01 \x03(\fR\vcapduHeader\x12\x1d\n" +
	"\n" +
	"capdu_data\x18\x02 \x03(\fR\tcapduData\x12\x14\n" +
	"\x05rapdu\x18\x03 \x01(\fR\x05rapdu\x12\x1e\n" +
	"\n" +
	"persistent\x18\x04 \x01(\bR\n" +
	"persistent\x12+\n" +
	"\x11persist_reconnect\x18\a \x01(\bR\x10persistReconnect\x12\x1d\n" +
	"\n" +
	"send_capdu\x18\x05 \x01(\bR\tsendCapdu\x12F\n" +
	"\fchained_next\x18\x06 \x03(\v2#.nv.subspacerelay.EmulationShortcutR\vchainedNext\"\xc7\x01\n" +
	"\tReconnect\x12\x10\n" +
	"\x03uid\x18\x02 \x01(\fR\x03uid\x12\x10\n" +
	"\x03ats\x18\x03 \x01(\fR\x03ats\x12\x19\n" +
	"\baid_list\x18\x04 \x03(\fR\aaidList\x12A\n" +
	"\tshortcuts\x18\x05 \x03(\v2#.nv.subspacerelay.EmulationShortcutR\tshortcuts\x122\n" +
	"\x15force_flush_shortcuts\x18\x06 \x01(\bR\x13forceFlushShortcutsJ\x04\b\x01\x10\x02\"\xdd\x03\n" +
	"\tRelayInfo\x12U\n" +
	"\x17supported_payload_types\x18\x01 \x03(\x0e2\x1d.nv.subspacerelay.PayloadTypeR\x15supportedPayloadTypes\x12I\n" +
	"\x0fconnection_type\x18\x05 \x01(\x0e2 .nv.subspacerelay.ConnectionTypeR\x0econnectionType\x12\x10\n" +
	"\x03atr\x18\x02 \x01(\fR\x03atr\x12\x1f\n" +
	"\vdevice_name\x18\x03 \x01(\tR\n" +
	"deviceName\x12%\n" +
	"\x0edevice_address\x18\x04 \x01(\fR\rdeviceAddress\x12\x12\n" +
	"\x04rssi\x18\x06 \x01(\x11R\x04rssi\x12+\n" +
	"\x11supports_shortcut\x18\a \x01(\bR\x10supportsShortcut\x12*\n" +
	"\x11requires_aid_list\x18\b \x01(\bR\x0frequiresAidList\x12\x1d\n" +
	"\n" +
	"user_agent\x18\t \x01(\tR\tuserAgent\x12\x10\n" +
	"\x03uid\x18\n" +
	" \x01(\fR\x03uid\x12\x12\n" +
	"\x04atqa\x18\v \x01(\fR\x04atqa\x12\x10\n" +
	"\x03sak\x18\f \x01(\fR\x03sak\x12\x10\n" +
	"\x03ats\x18\r \x01(\fR\x03ats\"\x8f\x01\n" +
	"\x15RequestRelayDiscovery\x122\n" +
	"\x15controller_public_key\x18\x01 \x01(\fR\x13controllerPublicKey\x12B\n" +
	"\rpayload_types\x18\x02 \x03(\x0e2\x1d.nv.subspacerelay.PayloadTypeR\fpayloadTypes\"g\n" +
	"\x0eRelayDiscovery\x12\x19\n" +
	"\brelay_id\x18\x01 \x01(\tR\arelayId\x12:\n" +
	"\n" +
	"relay_info\x18\x02 \x01(\v2\x1b.nv.subspacerelay.RelayInfoR\trelayInfo\"\xb3\x01\n" +
	"\x17RelayDiscoveryEncrypted\x122\n" +
	"\x15controller_public_key\x18\x01 \x01(\fR\x13controllerPublicKey\x12(\n" +
	"\x10relay_public_key\x18\x02 \x01(\fR\x0erelayPublicKey\x12:\n" +
	"\x19encrypted_relay_discovery\x18\x03 \x01(\fR\x17encryptedRelayDiscovery\"\x1f\n" +
	"\x03Log\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage*\xc2\x01\n" +
	"\vPayloadType\x12\x1c\n" +
	"\x18PAYLOAD_TYPE_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14PAYLOAD_TYPE_ARTEMIS\x10\x01\x12\x1b\n" +
	"\x17PAYLOAD_TYPE_CARDHOPPER\x10\x02\x12\x1c\n" +
	"\x18PAYLOAD_TYPE_PCSC_READER\x10\x03\x12$\n" +
	" PAYLOAD_TYPE_PCSC_READER_CONTROL\x10\x05\x12\x1a\n" +
	"\x16PAYLOAD_TYPE_PCSC_CARD\x10\x04*\xd2\x01\n" +
	"\x0eConnectionType\x12\x1f\n" +
	"\x1bCONNECTION_TYPE_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14CONNECTION_TYPE_PCSC\x10\x01\x12\x1f\n" +
	"\x1bCONNECTION_TYPE_PCSC_DIRECT\x10\x06\x12\x18\n" +
	"\x14CONNECTION_TYPE_UART\x10\x02\x12\x18\n" +
	"\x14CONNECTION_TYPE_OSDP\x10\x03\x12\x17\n" +
	"\x13CONNECTION_TYPE_NFC\x10\x04\x12\x17\n" +
	"\x13CONNECTION_TYPE_BLE\x10\x05B/Z-github.com/nvx/subspace-relay;subspacerelaypbb\x06proto3"

var (
	file_nv_subspacerelay_subspacerelay_proto_rawDescOnce sync.Once
	file_nv_subspacerelay_subspacerelay_proto_rawDescData []byte
)

func file_nv_subspacerelay_subspacerelay_proto_rawDescGZIP() []byte {
	file_nv_subspacerelay_subspacerelay_proto_rawDescOnce.Do(func() {
		file_nv_subspacerelay_subspacerelay_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_nv_subspacerelay_subspacerelay_proto_rawDesc), len(file_nv_subspacerelay_subspacerelay_proto_rawDesc)))
	})
	return file_nv_subspacerelay_subspacerelay_proto_rawDescData
}

var file_nv_subspacerelay_subspacerelay_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_nv_subspacerelay_subspacerelay_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_nv_subspacerelay_subspacerelay_proto_goTypes = []any{
	(PayloadType)(0),                // 0: nv.subspacerelay.PayloadType
	(ConnectionType)(0),             // 1: nv.subspacerelay.ConnectionType
	(*Message)(nil),                 // 2: nv.subspacerelay.Message
	(*Payload)(nil),                 // 3: nv.subspacerelay.Payload
	(*EmulationShortcut)(nil),       // 4: nv.subspacerelay.EmulationShortcut
	(*Reconnect)(nil),               // 5: nv.subspacerelay.Reconnect
	(*RelayInfo)(nil),               // 6: nv.subspacerelay.RelayInfo
	(*RequestRelayDiscovery)(nil),   // 7: nv.subspacerelay.RequestRelayDiscovery
	(*RelayDiscovery)(nil),          // 8: nv.subspacerelay.RelayDiscovery
	(*RelayDiscoveryEncrypted)(nil), // 9: nv.subspacerelay.RelayDiscoveryEncrypted
	(*Log)(nil),                     // 10: nv.subspacerelay.Log
	(*emptypb.Empty)(nil),           // 11: google.protobuf.Empty
}
var file_nv_subspacerelay_subspacerelay_proto_depIdxs = []int32{
	3,  // 0: nv.subspacerelay.Message.payload:type_name -> nv.subspacerelay.Payload
	4,  // 1: nv.subspacerelay.Message.emulation_shortcut:type_name -> nv.subspacerelay.EmulationShortcut
	11, // 2: nv.subspacerelay.Message.request_relay_info:type_name -> google.protobuf.Empty
	6,  // 3: nv.subspacerelay.Message.relay_info:type_name -> nv.subspacerelay.RelayInfo
	10, // 4: nv.subspacerelay.Message.log:type_name -> nv.subspacerelay.Log
	5,  // 5: nv.subspacerelay.Message.reconnect:type_name -> nv.subspacerelay.Reconnect
	11, // 6: nv.subspacerelay.Message.disconnect:type_name -> google.protobuf.Empty
	7,  // 7: nv.subspacerelay.Message.request_relay_discovery:type_name -> nv.subspacerelay.RequestRelayDiscovery
	8,  // 8: nv.subspacerelay.Message.relay_discovery_plaintext:type_name -> nv.subspacerelay.RelayDiscovery
	9,  // 9: nv.subspacerelay.Message.relay_discovery_encrypted:type_name -> nv.subspacerelay.RelayDiscoveryEncrypted
	0,  // 10: nv.subspacerelay.Payload.payload_type:type_name -> nv.subspacerelay.PayloadType
	4,  // 11: nv.subspacerelay.EmulationShortcut.chained_next:type_name -> nv.subspacerelay.EmulationShortcut
	4,  // 12: nv.subspacerelay.Reconnect.shortcuts:type_name -> nv.subspacerelay.EmulationShortcut
	0,  // 13: nv.subspacerelay.RelayInfo.supported_payload_types:type_name -> nv.subspacerelay.PayloadType
	1,  // 14: nv.subspacerelay.RelayInfo.connection_type:type_name -> nv.subspacerelay.ConnectionType
	0,  // 15: nv.subspacerelay.RequestRelayDiscovery.payload_types:type_name -> nv.subspacerelay.PayloadType
	6,  // 16: nv.subspacerelay.RelayDiscovery.relay_info:type_name -> nv.subspacerelay.RelayInfo
	17, // [17:17] is the sub-list for method output_type
	17, // [17:17] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_nv_subspacerelay_subspacerelay_proto_init() }
func file_nv_subspacerelay_subspacerelay_proto_init() {
	if File_nv_subspacerelay_subspacerelay_proto != nil {
		return
	}
	file_nv_subspacerelay_subspacerelay_proto_msgTypes[0].OneofWrappers = []any{
		(*Message_Payload)(nil),
		(*Message_EmulationShortcut)(nil),
		(*Message_RequestRelayInfo)(nil),
		(*Message_RelayInfo)(nil),
		(*Message_Log)(nil),
		(*Message_Reconnect)(nil),
		(*Message_Disconnect)(nil),
		(*Message_RequestRelayDiscovery)(nil),
		(*Message_RelayDiscoveryPlaintext)(nil),
		(*Message_RelayDiscoveryEncrypted)(nil),
	}
	file_nv_subspacerelay_subspacerelay_proto_msgTypes[1].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_nv_subspacerelay_subspacerelay_proto_rawDesc), len(file_nv_subspacerelay_subspacerelay_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_nv_subspacerelay_subspacerelay_proto_goTypes,
		DependencyIndexes: file_nv_subspacerelay_subspacerelay_proto_depIdxs,
		EnumInfos:         file_nv_subspacerelay_subspacerelay_proto_enumTypes,
		MessageInfos:      file_nv_subspacerelay_subspacerelay_proto_msgTypes,
	}.Build()
	File_nv_subspacerelay_subspacerelay_proto = out.File
	file_nv_subspacerelay_subspacerelay_proto_goTypes = nil
	file_nv_subspacerelay_subspacerelay_proto_depIdxs = nil
}
